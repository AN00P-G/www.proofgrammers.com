---
title: "Introduction to Theoretical Machines"
description: "Exploring theory of computation with Python"
date: "2025-08-25"
date-format: long
author: Gregory M. Kapfhammer
execute:
  echo: true
format:
  live-revealjs:
    completion: true
    theme: default
    css: ../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Proofgrammers"
---

# Theory of computation

::: {.fragment style="margin-top: -0.5em; font-size: 0.80em;"} 

- {{< iconify fa6-solid lightbulb >}} **What is theory of computation?**
    - Understanding what can be computed
    - Analyzing computational complexity
    - Proving limits of computation
    - "Proofgrammers" combine *proofs* and *programming*

:::

::: {.fragment style="margin-top: -0.5em; font-size: 0.80em;"}

- {{< iconify fa6-solid lightbulb >}} **Why is it important?**
    - Foundation of computer science
        - Helps determine if problems are solvable
        - Guides algorithm design choices
        - Reveals fundamental computational limits
        - Powers modern cryptography and security

:::

## Becoming a proofgrammer

::: {.incremental style="margin-top: -0.15em; font-size: 0.95em;"}

- {{< iconify fa6-solid gear >}} **Master Python programming**
  - Implement theoretical concepts as code
  - Express mathematical proofs as programs
  - Analyze algorithmic complexity
- {{< iconify fa6-solid gear >}} **Understand computational theory**
  - Automata and formal languages
  - Decidability and undecidability
  - Complexity classes and reductions
- {{< iconify fa6-solid lightbulb >}} **Use programming to explore what can be computed!**

:::

## What does a proofgrammer do?

::: {.fragment style="margin-top: 0.1em; font-size: 0.9em;"}

- **Proof** (mathematical verification) meets **Programming** (code implementation)
- Implement Turing machines and automata
- Prove undecidability results with code
- Analyze algorithmic complexity experimentally
- Create computational models of theoretical concepts
- Verify theoretical results through programming

:::

::: {.fragment .fade .boxed-content style="margin-top: 0.25em; font-size: 0.9em;"}

{{< iconify fa6-solid microscope >}} How do we *prove* computational limits
using code? *...* How do we *implement* theoretical machines? *...* How do we
*verify* complexity results? *...*

:::

## Computable problems with Python

```{python}
from typing import List
from pathlib import Path

def count_lines(file_content: str) -> int:
    """Count the number of lines in the provided text content."""
    if not file_content:
        return 0
    lines = file_content.split('\n')
    return len(lines)

# example source code content
sample_code = """def hello_world():
    print("Hello, Proofgrammers!")
    return True

def main():
    result = hello_world()
    print(f"Function executed: {result}")

if __name__ == "__main__":
    main()"""

# count lines in the sample code
line_count = count_lines(sample_code)
print(f"Number of lines in the sample code: {line_count}")
print(f"This is a computable problem - we can always determine the line count!")
```

::: {.fragment style="margin-top: -0.25em; font-size: 0.80em;"}

- **Computable problems**: have clear, algorithmic solutions
- **Line counting**: decidable and tractable for any finite input

:::

## Try the `count_lines` function

```{pyodide}
#| autorun: true
#| max-lines: 10
def count_lines(file_content: str) -> int:
    """Count the number of lines in the provided text content."""
    if not file_content:
        return 0
    lines = file_content.split('\n')
    return len(lines)

# test with sample code
test_code = """def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

print(fibonacci(5))"""

line_count = count_lines(test_code)
print(f"Lines in Fibonacci code: {line_count}")
print("Try changing the code above to see the count change!")
```

::: {.fragment style="margin-top: -0.25em; font-size: 0.80em;"}

- **Important question**: what makes this problem computable?

:::

## Universal computation with Python

```{python}
def universal(prog_string: str, input_string: str) -> str:
    """Execute a program given as a string on the provided input."""
    # Create a local namespace for the program execution
    local_namespace = {}
    # Execute the program definition to make the function available
    exec(prog_string, {}, local_namespace)
    # Extract the main function from the executed program
    main_function = None
    for name, obj in local_namespace.items():
        if callable(obj) and not name.startswith('_'):
            main_function = obj
            break
    # Execute the program with the given input
    if main_function:
        return main_function(input_string)
    else:
        return "No function found"

# Example program that checks if a string contains "GAGA"
contains_gaga_program = '''
def contains_gaga(input_str):
    """Check if the input string contains GAGA."""
    if "GAGA" in input_str:
        return "yes"
    else:
        return "no"
'''
```

::: {.fragment style="margin-top: 0.1em; font-size: 0.80em;"}

- `universal`: demonstrates one program executing another program
- Foundation of **universal computation** and general-purpose computers

:::

## Testing universal computation

```{python}
#| freeze: auto
# Demonstrate universal computation
test_string1 = "HELLO GAGA WORLD"
test_string2 = "programming"

# Example program that counts vowels
count_vowels_program = '''
def count_vowels(input_str):
    """Count the number of vowels in the input string."""
    vowels = "aeiouAEIOU"
    count = sum(1 for char in input_str if char in vowels)
    return str(count)
'''

print("Universal Computation in Action:")
print("================================")
print(f"Testing contains_gaga with '{test_string1}':")
result1 = universal(contains_gaga_program, test_string1)
print(f"Result: {result1}")

print(f"\nTesting count_vowels with '{test_string2}':")
result2 = universal(count_vowels_program, test_string2)
print(f"Result: {result2}")

print(f"\nThis demonstrates universal computation - one program simulating others!")
```

## Discuss computation results

::: {.fragment style="margin-top: 0.1em; font-size: 0.85em;"}

- {{< iconify game-icons team-idea >}} **Discuss in your teams:**
    - What makes the line counting problem computable?
    - How does universal computation relate to general-purpose computers?
    - What are the theoretical implications of programs executing programs?

:::

## Essential tools

- Terminal window for command-line operations
- Git and GitHub for version control and collaboration
- VS Code for writing and testing Python code
- UV for Python package and dependency management
- Quarto for creating interactive documents with code

::: {.fragment .fade .boxed-content style="margin-top: 0.25em; font-size: 0.9em;"}

{{< iconify fa6-solid microscope >}} How do we *implement* theoretical concepts
in code? *...* How do we *verify* computational results? *...* How do we
*document* our proofs effectively? *...*

:::

## Real-world computational challenges

::: {.incremental style="margin-top: -0.15em; font-size: 0.95em;"}

- {{< iconify fa6-solid gear >}} **Characterize computational problems?**
  - What makes a problem computable or non-computable?
  - How do we measure algorithmic complexity?
  - What are the fundamental limits of computation?
- {{< iconify fa6-solid gear >}} **Compare and analyze algorithms?**
  - Which approach is more efficient for large inputs?
  - How do we prove correctness of our implementations?
  - What tools help us understand computational behavior?
  - How do we verify theoretical results experimentally?

:::

## Why is theory of computation challenging?

::: {.fragment}

- Abstract concepts require concrete implementations
- Proofs must be both rigorous and programmable
- Complexity analysis involves both theory and experimentation
- Undecidability results challenge intuition
- Connecting mathematical theory to practical programming
- Understanding fundamental computational limits

:::

## Proofgrammer development environment

::: {.fragment style="margin-top: 0.1em; font-size: 0.9em;"}

- Terminal with command-line access for tool execution
- Version control system (Git with GitHub)
- Python development environment (UV + Python 3.12+)
- Code editor with syntax highlighting (VS Code + extensions)
- Documentation system (Quarto for interactive code/text)
- AI coding assistants (GitHub Copilot, Google Gemini CLI, OpenCode)
- Testing and verification tools for computational proofs
- Mathematical notation support for theoretical concepts

:::

## Learn more about theory of computation

:::: {.columns}

::: {.column width="50%"}

{{< iconify fa6-solid book-open >}} Explore the ["What Can be Computed" textbook](https://whatcanbecomputed.com/) and [Python documentation](https://docs.python.org/)

:::

::: {.column width="50%"}

{{< iconify fa6-brands github >}} Review computational examples like [WCBC code](https://github.com/johnmaccormick/wcbc-programs) and [theory implementations](https://github.com/topics/theory-of-computation)

:::

::::

::: {.fragment .fade-down style="margin-top: -0.15em; font-size: 0.9em;"}

- Theory of computation requires both mathematical and programming skills
- Key areas of focus:
  - Python programming for theoretical concepts
  - Automata theory and formal languages  
  - Computational complexity and analysis
  - Decidability and undecidability proofs
- Experimental verification of theoretical results

:::

## Theory of computation with AI

::: {.fragment style="margin-top: 0.1em; font-size: 0.9em;"}

- AI tools like GitHub Copilot, Google Gemini CLI, or OpenCode assist with code:
  - Is the generated code theoretically correct and well-implemented?
  - Can the generated code help verify mathematical proofs?
  - Does the generated code follow computational complexity best practices?
  - Can you integrate AI-generated code into your proof workflows?
  - Can you maintain theoretical rigor while using AI assistance?

:::

::: {.fragment .fade .boxed-content style="margin-top: -0.1em; font-size: 0.8em;"}

{{< iconify fa6-solid lightbulb >}} Proofgrammers who use AI coding tools are
responsible for ensuring correctness, theoretical accuracy, and ethical use!

:::

## Development environment setup

- *Installing* essential tools for proofgrammers
- *Configuring* development environment for theoretical computation

## Essential tools for proofgrammers

::: {.fragment .fade .boxed-content style="font-size: 1.0em;"}

```{.text  code-line-numbers="false"}
Tools for Theory of Computation
Terminal: Command-line interface for running computational tools
Git: Version control for tracking code and proof development
GitHub: Cloud platform for collaboration and project hosting
VS Code: Code editor with extensions for Python and theory work
```

:::

::: {.fragment .fade-up style="font-size: 0.9em;"}

- **Terminal**: Essential for running computational tools, executing Python
scripts, and automating proof verification. Available on all operating systems
(Windows Terminal, macOS Terminal, or Linux terminal emulators).
- **Git and GitHub**: Industry-standard version control and collaboration
platform for tracking changes in code implementations of theoretical concepts
and enabling team-based proof development.
- **Testing**: Run `git --version` and create a test repository on GitHub

:::

## Installing UV and Python

::: {.incremental style="margin-top: -0.15em; font-size: 0.95em;"}

- {{< iconify fa6-solid gear >}} **UV: Modern Python package and project manager**
  - Install from [astral-sh.github.io/uv](https://astral-sh.github.io/uv/)
  - Cross-platform: `curl -LsSf https://astral.sh/uv/install.sh | sh` (Unix)
  - Windows: `powershell -c "irm https://astral.sh/uv/install.ps1 | iex"`
- {{< iconify fa6-solid gear >}} **Python 3.12+ via UV (recommended approach)**
  - Use `uv python install 3.12` to install Python
  - Create virtual environments with `uv venv`
  - Install packages with `uv add package-name`
- {{< iconify fa6-solid lightbulb >}} **Why UV for proofgrammers?** Fast, reliable dependency management for computational theory projects!

:::

## Setting up VS Code for computation

```python
# Example VS Code extensions for proofgrammers
extensions = [
    "ms-python.python",           # Python development
    "quarto.quarto",             # Quarto documents
    "yzhang.markdown-all-in-one", # Markdown editing
    "ms-vscode.vscode-json",     # JSON configuration
    "github.vscode-github-actions", # GitHub workflow editing
]
```

::: {.fragment .fade style="margin-top: 0.5em; font-size: 0.9em;"}

- Install VS Code from [code.visualstudio.com](https://code.visualstudio.com/)
- Use built-in extension marketplace to install proofgrammer tools
- **Testing**: Create a `.py` file and verify syntax highlighting works

:::

## Installing Quarto for computation

::: {.incremental style="margin-top: -0.15em; font-size: 0.95em;"}

- {{< iconify fa6-solid gear >}} **Quarto: Scientific and technical publishing**
  - Download from [quarto.org](https://quarto.org/docs/get-started/)
  - Cross-platform installer available for Windows, macOS, Linux
  - Combines code, text, and mathematical notation in documents
- {{< iconify fa6-solid gear >}} **VS Code Quarto extension**
  - Install the official Quarto extension in VS Code
  - Enables live preview and code execution in `.qmd` files
  - Provides syntax highlighting and auto-completion
- {{< iconify fa6-solid lightbulb >}} **Why Quarto for proofgrammers?** Create reproducible documents that blend mathematical proofs with Python implementations!

:::

## Node.js tools for proofgrammers

```bash
# Install Node.js and npm from nodejs.org
# Then use npx to run tools without permanent installation
npx @google/generative-ai-cli --version  # Google Gemini CLI
npx opencode --version                   # OpenCode AI assistant
```

::: {.fragment .fade style="margin-top: 0.5em; font-size: 0.9em;"}

- **Node.js**: JavaScript runtime enabling AI-powered coding assistants
- **NPX**: Run packages without installing globally, keeps system clean
- **Testing**: Run `node --version` and `npm --version` to verify installation

:::

## GitHub Student Benefits and Copilot

::: {.incremental style="margin-top: -0.15em; font-size: 0.95em;"}

- {{< iconify fa6-solid gear >}} **GitHub Student Developer Pack**
  - Free access to premium developer tools and services
  - Apply at [education.github.com](https://education.github.com/pack)
  - Requires verification with .edu email or student ID
- {{< iconify fa6-solid gear >}} **GitHub Copilot Pro for Students**
  - AI-powered code completion and generation
  - Free for verified students and educators
  - Integrates with VS Code and other editors
- {{< iconify fa6-solid lightbulb >}} **Why GitHub tools for proofgrammers?** Essential for collaborative proof development and AI-assisted coding!

:::

## Testing your proofgrammer setup

```bash
# Essential verification commands
git --version                    # Check Git installation
python --version                 # Check Python (via UV)
quarto --version                # Check Quarto installation
code --version                  # Check VS Code installation
uv --version                    # Check UV package manager
```

::: {.fragment .fade style="margin-top: 0.5em; font-size: 0.9em;"}

- **Test each tool individually** before starting computational projects
- **Create a test document** with code and mathematical notation to verify integration
- **Consult documentation** links when troubleshooting: [UV docs](https://docs.astral.sh/uv/), [Quarto docs](https://quarto.org/docs/), [VS Code docs](https://code.visualstudio.com/docs)

:::

## Proofgrammer tools and workflows

::: {.fragment .fade style="margin-top: -0.15em; font-size: 0.875em;"}

- **Theory of Computation Projects**
  - Latest version of Python via UV package manager
  - Use UV to manage virtual environments and dependencies
  - Use Git with instructor-provided computational repositories
  - Create, edit, and preview documents with Quarto and VS Code

:::

::: {.fragment .fade style="margin-top: -0.45em; font-size: 0.875em;"}

- **Collaborative Proof Projects**
  - Use the same tools as in individual projects
  - Use Git and GitHub flow for collaborative proof development workflows
  - Use Quarto to render previews of mathematical and computational content
  - Use VS Code extensions to run and test theoretical implementations

:::

## Setup requirements for proofgrammers

::: {.fragment .callout-note icon=true title="Tips for effective computational theory setup"}

- Devote time outside class to installing and configuring tools
- Confirm that all tools work during the first lab session
- Create and render test documents with the provided examples
- Complete the first theory of computation project on time
- Contribute to collaborative proof development projects
- Prepare for computational skill demonstrations

{{< iconify fa6-solid rocket >}} **Get ready for an exciting journey into theoretical machines!**

:::

## Goals of theory of computation

::: {.fragment .fade style="margin-top: -0.15em; font-size: 0.875em;"}

- **Computational Implementation**:
  - Design and implement theoretical concepts as Python programs
  - Test all aspects of implementations to ensure correctness
  - Create frameworks for automated proof verification
- **Theoretical Analysis**:
  - Design experiments to answer questions about computational complexity
  - Collect and analyze data about algorithm performance
  - Visualize insights to understand computational behavior
- **Communicate** results and theoretical insights through code and documentation
- **Check syllabus for details about the Theory of Computation course!**

:::
