---
title: "Formally Defining Computation"
description: "Exploring SISO programs and computational theory"
date: "2025-09-01"
date-format: long
author: Gregory M. Kapfhammer
execute:
  echo: true
format:
  live-revealjs:
    completion: true
    theme: default
    css: ../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Proofgrammers"
---

# Course objectives

::: {.incremental style="margin-top: -0.5em; font-size: 0.8em;"} 

- {{< iconify fa6-solid lightbulb >}} **What can be computed?**
    - **In principle**: undecidability and uncomputability
    - **Efficiently in practice**: complexity theory
    - **Formal mathematical foundations for computation**

:::

::: {.incremental style="margin-top: -0.5em; font-size: 0.8em;"}

- {{< iconify fa6-solid lightbulb >}} **Why study computational theory?**
    - Determine if problems are computable and tractable
    - Find suitable variants when problems are intractable
    - Compare efficiency of proposed solution methods
    - Apply techniques like reductions and automata theory

:::

## Why theory of computation matters

::: {.incremental style="margin-top: -0.2em; font-size: 0.85em;"}

- {{< iconify fa6-solid gear >}} **Practical utility**
  - Understand whether problems are computable and tractable
  - Find suitable variants or approximations when needed
  - Compare efficiency of different solution methods
  - Apply specific techniques with real applications

:::

::: {.incremental style="margin-top: -0.35em; font-size: 0.85em;"}

- {{< iconify fa6-solid gear >}} **Intellectual foundation**
  - Beautiful and important theoretical framework
  - Deeper understanding of computer science discipline
  - Rigorous mathematical basis for computation
  - Connect abstract concepts to practical programming

:::

## Computational problem classification

::: {.fragment style="margin-top: -0.5em; font-size: 0.8em;"}


| Category | Tractable | Intractable | Uncomputable |
|:--------:|:---------:|:-----------:|:------------:|
| **Description** | Can be solved efficiently | Method exists but hopelessly time-consuming | Cannot be solved by any program |
| **Theory** |  ✓ |  ✓ |  ✗ |
| **Practice** | ✓ |  ✗ (?) |  ✗ |
| **Example** |  Shortest route |  Decryption |  Finding all bugs |


:::

::: {.fragment .fade .boxed-content style="margin-top: 0.5em; font-size: 0.8em;"}

{{< iconify fa6-solid microscope >}} Understanding these categories helps
proofgrammers determine the computational feasibility of problems and select
appropriate solution strategies. **Proofgrammers understand that not all problems
are computable, and that some problems are intractable! Be on alert!**

:::

# Using Python for theoretical machines

::: incremental

- Introduce a restricted form of Python programs
- Give examples of these restricted programs
- Formally define the term "Python program"
- Introduce concept of a decision problem

:::

## Python basics for proofgrammers

::: {.fragment style="margin-top: 0.1em; font-size: 0.85em;"}

- **`utils` package**: provided with WCBC online resources
- **`rf` function**: reads files from disk, used frequently
- **`def` keyword**: defines functions like procedures in other languages
- **`in` operator**: works on many data types, tests substring presence
- **String quotes**: use single or double quotes for strings
- **Code blocks**: defined by indentation, no curly braces needed

:::

::: {.fragment .fade .boxed-content style="margin-top: 0.25em; font-size: 0.85em;"}

{{< iconify fa6-solid lightbulb >}} These Python fundamentals enable us to
implement theoretical concepts as executable programs that demonstrate
computational principles. We use Python programs to illuminate computational
theory!

:::

## Introducing SISO programs

::: {.incremental style="margin-top: -0.2em; font-size: 0.85em;"}

- {{< iconify fa6-solid gear >}} **Single Input, Single Output (SISO)**
  - Takes exactly one string as input parameter
  - Returns exactly one string as output result
  - Foundation for formal computational models
  - Enables precise mathematical analysis

:::

::: {.incremental style="margin-top: -0.4em; font-size: 0.85em;"}

- {{< iconify fa6-solid gear >}} **Decision problems**
  - Return "yes" or "no" to answer specific questions
  - Fundamental building blocks of computational theory
  - Enable formal proofs about computability
  - Connect to language recognition problems

:::

## SISO program characteristics

::: {.fragment style="margin-top: 0.1em; font-size: 0.85em;"}

- **Input specification**: single string parameter only
- **Output format**: single string return value
- **Function definition**: clear computational procedure
- **Deterministic behavior**: same input always produces same output
- **Finite execution**: program must terminate for valid inputs
- **String processing**: fundamental operation in formal languages

:::

::: {.fragment .fade .boxed-content style="margin-top: 0.25em; font-size: 0.85em;"}

{{< iconify fa6-solid microscope >}} SISO programs provide the mathematical
foundation for analyzing what can be computed and how efficiently we can solve
different types of problems. They are a powerful syntactic subset of Python! Go
SISO!

:::

## Why is SISO suitable?

::: {.incremental style="margin-top: 0em; font-size: 0.875em;"}

- Wait, real-world programs receive many kinds of input and output!
- But our theoretical results for SISO programs can be easily generalized to all
other types of computer programs
    - All input and output to computers ultimately consists of binary
    - Binary strings can easily be converted to and from ASCII strings
- The restriction to Python is convenient for us, but not strictly needed
- Python programs are equivalent to other standard models of computation,
including Turing machines and all other "reasonable" programming languages and
realistic computers
- **Unless otherwise specified, assume that all programs are SISO!**

:::

## Create the `containsGAGA` function

```{python}
def containsGAGA(input_string: str) -> str:
    """Check if the input string contains the substring GAGA."""
    if "GAGA" in input_string:
        return "yes"
    else:
        return "no"

# test the function with sample inputs
test_input1 = "HELLO GAGA WORLD"
test_input2 = "programming theory"
test_input3 = "AGAGAGAGA patterns"

print(f"Testing '{test_input1}': {containsGAGA(test_input1)}")
print(f"Testing '{test_input2}': {containsGAGA(test_input2)}")
print(f"Testing '{test_input3}': {containsGAGA(test_input3)}")
```


## Try the `containsGAGA` function

```{pyodide}
#| autorun: true
#| max-lines: 5
def containsGAGA(input_string: str) -> str:
    """Check if the input string contains the substring GAGA."""
    if "GAGA" in input_string:
        return "yes"
    else:
        return "no"

# test with various inputs
test_cases = [
    "GAGA music",
    "algorithms and data structures", 
    "AGAGAGAGA repeated patterns",
    "computational GAGA theory"
]
print("Testing containsGAGA function:")
print("=" * 30)
for test in test_cases:
    result = containsGAGA(test)
    print(f"Input: '{test}'")
    print(f"Output: {result}")
print("Try modifying the test cases above!")
```

## More sophisticated programs

```{pyodide}
#| autorun: true
#| max-lines: 10
def containsGAGAnotHAHA(input_string: str) -> str:
    """Return yes if input contains GAGA but not HAHA."""
    has_gaga = "GAGA" in input_string
    has_haha = "HAHA" in input_string
    if has_gaga and not has_haha:
        return "yes"
    else:
        return "no"

# test the enhanced function
test_cases = [
    "GAGA music rocks",
    "HAHA that is funny", 
    "GAGA and HAHA together",
    "neither pattern here",
    "GAGA without the funny one"
]
print("Testing containsGAGAnotHAHA function:")
for test in test_cases:
    result = containsGAGAnotHAHA(test)
    print(f"'{test}' → {result}")
```



## Reading programs from files

```{pyodide}
#| autorun: true
#| max-lines: 10
# simulate reading a program from a file
def rf(filename: str) -> str:
    """Simulate reading file content for demonstration."""
    # in practice, this would read from an actual file
    sample_programs = {
        "containsGAGA.py": '''def containsGAGA(input_string):
    return "yes" if "GAGA" in input_string else "no"''',
        "countVowels.py": '''def countVowels(input_string):
    vowels = "aeiouAEIOU"
    return str(sum(1 for char in input_string if char in vowels))'''
    }
    return sample_programs.get(filename, "# File not found")

# demonstrate reading program code
gaga_program = rf("containsGAGA.py")
vowel_program = rf("countVowels.py")
print("Contents of containsGAGA.py:")
print(gaga_program)
print("Contents of countVowels.py:")
print(vowel_program)
```

## Recap these two programs

::: {.fragment style="margin-top: 0.25em; font-size: 0.95em;"}

- Recap for the `containsGAGAnotHAHA` function:
    - **Complex conditions**: combining multiple pattern checks
    - **Boolean logic**: using `and` and `not` operators effectively
    - **Pattern exclusion**: ensuring one pattern without another

:::

::: {.fragment style="margin-top: 0.05em; font-size: 0.95em;"}

- Recap for the `rf` and `countVowels` functions:
    - **File operations**: reading program source code as data
    - **Program as data**: treating code as input to other programs
    - **Dynamic execution**: foundation for universal computation

:::

# Programs are data! Start thinking like a proofgrammer about universal computation!

## Next steps in computational theory

::: {.incremental style="margin-top: -0.15em; font-size: 0.95em;"}

- {{< iconify fa6-solid gear >}} **Deepen theoretical understanding**
  - Explore more complex computational models
  - Study formal language definitions and properties
  - Investigate decidability and undecidability results
  - Analyze computational complexity classes

:::

::: {.incremental style="margin-top: -0.15em; font-size: 0.95em;"}

- {{< iconify fa6-solid gear >}} **Apply programming skills**
  - Implement automata and Turing machines
  - Create programs that analyze other programs
  - Build tools for complexity measurement
  - Develop proofs through computational examples

:::

## Continue learning computational theory

:::: {.columns}

::: {.column width="50%"}

{{< iconify fa6-solid book-open >}} Study Chapter 1 of ["What Can be
Computed"](https://whatcanbecomputed.com/) and practice implementing SISO
programs

:::

::: {.column width="50%"}

{{< iconify fa6-brands github >}} Experiment with the [WCBC code
examples](https://whatcanbecomputed.com/) and create your own pattern-matching
programs

:::

::::

::: {.fragment .fade-down style="margin-top: -0.15em; font-size: 0.95em;"}

- {{< iconify fa6-solid lightbulb >}} **Focus areas for week two**:
  - SISO program implementation and analysis
  - Decision problems and their computational properties
  - String processing and pattern recognition algorithms
  - Connection between programming and mathematical theory
  - Preparation for more advanced computational models

:::

# Ready to formally define what it means to compute? Let's implement more SISO programs!
