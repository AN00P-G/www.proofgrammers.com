---
title: "Multiple Sequence Alignment"
description: "Explain intractability of DNA fragment alignment"
date: "2025-09-01"
date-format: long
author: Hemani Alaparthi, Will Bennett, Coltin Colucci
execute:
  echo: true
format:
  live-revealjs:
    completion: true
    theme: default
    css: ../../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Proofgrammers"
---

# Introduction

Will's Part

# Code Implementation

## Hemani's Implementation

```{python}
def align_dna_sequences(sequences):
    """
    Simple DNA sequence alignment function.
    Takes a list of DNA sequences and returns them aligned.
    """

    if len(sequences) < 2:
        return sequences

    # start with the first sequence
    aligned = [sequences[0]]

    # add each other sequence one by one
    for new_seq in sequences[1:]:
        best_alignment = None
        best_score = -999

        # try placing the new sequence at different positions
        for offset in range(-len(new_seq), len(aligned[0]) + 1):
            # Create test alignment
            test_aligned = []

            # copy existing sequences
            for seq in aligned:
                if offset < 0:
                    # need to add gaps to the left of existing sequences
                    test_aligned.append('-' * abs(offset) + seq)
                else:
                    test_aligned.append(seq)

            # add new sequence with gaps
            if offset >= 0:
                new_with_gaps = '-' * offset + new_seq
            else:
                new_with_gaps = new_seq

            # make all sequences the same length
            max_len = max(len(s) for s in test_aligned + [new_with_gaps])
            test_aligned = [s + '-' * (max_len - len(s)) for s in test_aligned]
            new_with_gaps = new_with_gaps + '-' * (max_len - len(new_with_gaps))
            test_aligned.append(new_with_gaps)

            # score this alignment (count matches)
            score = 0
            for pos in range(max_len):
                column = [seq[pos] for seq in test_aligned]
                # count how many characters match the most common one
                for char in 'ACGT':
                    count = column.count(char)
                    if count > 1:
                        score += count * 2  # bonus for matches

                score -= column.count('-')  # penalty for gaps

            # keep track of best alignment
            if score > best_score:
                best_score = score
                best_alignment = test_aligned

        aligned = best_alignment

    return aligned

# example DNA sequences
sequences = [
    "CGGATTA",
    "CAGGGATA",
    "CGCTA",
]
aligned = align_dna_sequences(sequences)
print("Aligned DNA Sequences:")
for seq in aligned:
    print(seq)
```

## What's Going On Here?

::: {.callout-note}
**Code Explanation:**

This function aligns multiple DNA sequences by trying all possible ways to insert gaps and maximize matches. For each new sequence, it tests every possible offset, adds gaps as needed, and scores the alignment based on matching characters and gap penalties. The alignment with the highest score is chosen. This brute-force approach is simple but becomes extremely slow for many or long sequences, illustrating why multiple sequence alignment is computationally intractable.
:::

This algorithm works, but it takes exponential time which is roughly `O(2^(n√óm))`, where `n` = number of sequences and `m` = sequence length.

## Coltin's Implementation

```{python}
def align_sequences(sequences):
    """Aligns a list of sequences and prints them with mismatches highlighted."""
    ref = sequences[0]      # Use first sequence as reference
    aligned = [list(ref)]   # Start aligned list with reference sequence

    for seq in sequences[1:]:
        aligned_seq = []
        # compare each character in the reference to the current sequence
        for r, s in zip(ref, seq.ljust(len(ref))):      # add spaces to shorter seq
            if r == s:
                aligned_seq.append(s)    # match keep character
            else:
                aligned_seq.append(" ")  # mismatch insert space
        aligned.append(aligned_seq)      # add aligned sequence to list

    # Print results
    for seq in aligned:
        print("".join(seq))


if __name__ == "__main__":
    sequences = [
        "caggatta",
        "cagggata",
        "cgcctatt",
        "cagaatta"
    ]
    align_sequences(sequences)
```

## What's Going On Here?


::: {.callout-note}
**Code Explanation:**

This function aligns a list of sequences by using the first sequence as a reference. For each additional sequence it compares each character to the reference at the same position. If the characters match it keeps the character if not it inserts a space to highlight the mismatch compared to the original reference sequence. Shorter sequences get spaces added to them to match the reference sequences length. The result shows a simple visual alignment that makes mismatches easy to spot compared to the reference sequence. It does not insert gaps or optimize for the best overall alignment. This approach is fast and straightforward but is not very flexible for compared to more advanced alignments.

This algorithm is `O(n * m)` where `n` is the number of sequences and `m` is the length of the reference sequence. This algorithm processes each character in each sequence once making it somewhat scalable. 

# Intractable?

Seeing the above function you might ask yourself why this problem is intractable. The reason for this is that `align_sequences` is a limited version of aligning DNA sequences. it only compares the sequences to one reference sequence position by position without inserting gaps or shifting sequences to find the best possible alignment. 

A full sequence alignment algorithm tries every possible way to insert gaps and shift sequences to maximize matches across all sequences. This requires checking an exponential number of possible alignments making it computationally intractable for longer sequences. `align_sequences` is fast but limited compared to a full DNA sequence aligner. 

# Results

The output of the code above shows the aligned DNA sequences. For small inputs, the algorithm works, but for larger numbers of sequences or longer sequences, it becomes computationally infeasible due to exponential growth in possible alignments.

# Conclusion

**Why It Takes "Super Long"**

- **Time complexity**: For even modest inputs (e.g., 10 sequences of 100 bases each), the algorithm would need to check approximately 2^1000 possible alignments.
- **Exponential growth**: Adding just one more sequence doubles the problem size.

You guys can add more here (Talk about untractable, uncomputable and etc)

