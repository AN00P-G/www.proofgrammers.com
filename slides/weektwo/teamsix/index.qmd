---
title: "Build a Bug Detection System"
description: "Explore why bug detection is uncomputable"
date: "2025-09-01"
date-format: long
author: Preston Smith, Benedek Kaibas, Duru Akbas and Miguel Orti Vila
execute:
  echo: true
format:
  live-revealjs:
    completion: true
    theme: default
    css: ../../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Proofgrammers"
---

## What is Uncomputability?

- It isn't possible to algorithmically solve or do
- There isn't one program that can complete the task with every input

## Why is it Uncomputable?

![Book Figure](Screenshot%202025-09-01%20162256.png)

## Issues with defining bugs

- What a bug is not universal to every program
- Different programs can I have different definitions of what constitutes a bug
 

## What problems can you solve?

- You can write programs that detect bugs
- Can also detect specific kinds of bugs
- Bug detectors for specific programs

## Bug Detecting through Fuzzing

```{pyodide}
#| autorun: true
#| max-lines: 7
import random

def crash_on_input(source_code: str, input: str = ""):
    """Run a program with input and check if it crashes."""
    try:
        env = {"input": input}
        exec(source_code, env)
        return f"Program ran successfully on input|{input}|"
    except Exception as e:
        return f"Program crashed on input|{input}| with error: {e}"


test_source_code = """def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)
fibonacci(int(input))"""

choices = ["a","b","c","d","e","f","g","h","i",1,2,3,4,5,6,7,8,9]

inputs = [random.choice(choices) for _ in range(5)]
for input in inputs:
    print(f"{crash_on_input(test_source_code, input)}")
```

## What are unused variables?

```{pyodide}
#| autorun: false

"""File that contains function that has unused variable in it."""

def uv():
    """Function that has an unused variable in it."""
    iterator = 0
    limit = 100 # we use limit as an unused variable which our linter program has to catch
    while iterator != 50:
        print(iterator)

if __name__ == "__main__":
    uv()

```

## Detecting Unused variables

```{pyodide}
#| autorun: false

import ast

def read_file():
    with open("uv.py", "r") as fn:
        read_fn = fn.read()
    parser = ast.parse(read_fn)
    create_ast = ast.dump(parser, indent=4)
    return create_ast

def store_ast():
    ast_tree = read_file()

    with open("ast.txt", "w") as fn:
        write_fn = fn.write(ast_tree)
    
    return write_fn

def read_ast():
    with open("ast.txt", "r") as fn:
        lines = fn.readlines()

    for line in lines:
        split_lines = line.strip()
        word = "'limit'"

        if word in split_lines:
            count_word = word.count("'limit'")
        
            if count_word == 1:
                print(f"We found an unused variable: {word}")
            else:
                print("The file you have provided does not have unused variables!")



if __name__ == "__main__":
    read_ast()

```

## Detecting Unclosed Print Statements

```{pyodide}
#| autorun: true
#| max-lines: 15
import ast

def check_syntax(text: str):
    try:
        ast.parse(text)
        print("No syntax errors found.")
    except SyntaxError as e:
        print(f"Syntax error: {e}")

test_source_code = """def calculate_sum(numbers):
    total = 0
    for n in numbers:
        total += n
    if total > 10:
        print("Large sum"
    else:
        print("Small sum")
    return total

calculate_sum([1, 2, 3, 7])
"""

check_syntax(test_source_code)

```
