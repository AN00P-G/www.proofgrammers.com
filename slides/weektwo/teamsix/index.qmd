---
title: "Build a Bug Detection System"
description: "Explore why bug detection is uncomputable"
date: "2025-09-01"
date-format: long
author: Preston Smith, Benedek Kaibas, Duru Akbas and Miguel Orti Vila
execute:
  echo: true
format:
  live-revealjs:
    completion: true
    theme: default
    css: ../../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Proofgrammers"
---

## Bug Detecting through Fuzzing

```{pyodide}
#| autorun: true
#| max-lines: 7
import random

def crash_on_input(source_code: str, input: str = ""):
    """Run a program with input and check if it crashes."""
    try:
        env = {"input": input}
        exec(source_code, env)
        return f"Program ran successfully on input|{input}|"
    except Exception as e:
        return f"Program crashed on input|{input}| with error: {e}"


test_source_code = """def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)
fibonacci(int(input))"""

choices = ["a","b","c","d","e","f","g","h","i",1,2,3,4,5,6,7,8,9]

inputs = [random.choice(choices) for _ in range(5)]
for input in inputs:
    print(f"{crash_on_input(test_source_code, input)}")
```


## Detecting Syntactical Errors

```{pyodide}
#| autorun: true
#| max-lines: 10
import ast

def check_syntax(text: str):
    try:
        ast.parse(text)
        print("No syntax errors found.")
    except SyntaxError as e:
        print(f"Syntax error: {e}")
        

def run_scanner(source_code: str):
    check_syntax(source_code)

test_source_code = """def fibonacci(n):
    if n <= 1
        return n
    return fibonacci(n-1) + fibonacci(n-2)

print(fibonacci(5))"""

run_scanner(test_source_code)
```
## What are unused variables?

```{pyodide}
#| autorun: false

"""File that contains function that has unused variable in it."""

def uv():
    """Function that has an unused variable in it."""
    iterator = 0
    limit = 100 # we use limit as an unused variable which our linter program has to catch
    while iterator != 50:
        print(iterator)

if __name__ == "__main__":
    uv()

```

## Detecting Unused variables

```{pyodide}
#| autorun: false

import ast

def read_file():
    with open("uv.py", "r") as fn:
        read_fn = fn.read()
    parser = ast.parse(read_fn)
    create_ast = ast.dump(parser, indent=4)
    return create_ast

def store_ast():
    ast_tree = read_file()

    with open("ast.txt", "w") as fn:
        write_fn = fn.write(ast_tree)
    
    return write_fn

def read_ast():
    with open("ast.txt", "r") as fn:
        lines = fn.readlines()

    for line in lines:
        split_lines = line.strip()
        word = "'limit'"

        if word in split_lines:
            count_word = word.count("'limit'")
        
            if count_word == 1:
                print(f"We found an unused variable: {word}")
            else:
                print("The file you have provided does not have unused variables!")



if __name__ == "__main__":
    read_ast()

```

## What is Uncomputability?

- It isn't possible to algorithmically develop
- There is no general solution that can compute the answer

## Why is a full Bug Detector Uncomputable?

- Different programs have different criteria for what considered a bug
- Programs can crash intentionally
- There is no general purpose algorithm to find every bug for every program
