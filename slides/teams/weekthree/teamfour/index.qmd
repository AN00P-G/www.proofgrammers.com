---
title: "DetectThrowsException Decision Problem"
description: "Explore the detection of exception throwing"
date: "2025-09-08"
date-format: long
author: Anoop Guragain, Duru Akbas, Joseph Oforkansi
execute:
  echo: true
format:
  live-revealjs:
    completion: true
    theme: default
    css: ../../../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Proofgrammers"
---

# Introduction

## A simple exceptions "detection" program

- Takes an input that is a string containing source code
- Search through the source code line by line using regex for certain keys or pattern
- Add those lines that matches to a list called "warnings" with a message
- Convert that list into multi-line string and returns it

---

## To be noted

> - It does not detect, it just kind of predicts if the program is going to throw an exception.

> - It does not run the program or confirms that an exception will or won't occur.

> - It gives false positive and false negative such as it count comments and strings as the part of the source code

---

## Exceptions

- **Divisible by zero**

```python
 if re.search(r"/\s*0", line):
    warnings.append(f"Division by zero at line {i}")
```

- **Value error (int() and float())**

```python
  if "int(" in line or "float(" in line:
    warnings.append(f"Possible ValueError in conversion at line {i}")
```

- **Index error**

```python
  if re.search(r"\w+\[.*\]", line):
    warnings.append(f"Possible IndexError/KeyError at line {i}")
```

- **Raise**

```python
  if "raise " in line:
    warnings.append(f"Explicit raise at line {i}")
```

---

```{pyodide}
#| max-lines: 15
#| autorun: true

import re

def detect_exceptions(code: str) -> str:
    warnings = []
    lines = code.splitlines()

    for i, line in enumerate(lines, start=1):
        # Detect division by zero like 5/0 or 5 / 0
        if re.search(r"/\s*0", line):
            warnings.append(f"Division by zero at line {i}")
        # Detect int() and float() conversions
        if "int(" in line or "float(" in line:
            warnings.append(f"Possible ValueError in conversion at line {i}")
        # Detect indexing or dictionary access (possible IndexError/KeyError)
        if re.search(r"\w+\[.*\]", line):
            warnings.append(f"Possible IndexError/KeyError at line {i}")
        # Detect explicit raise statements
        if "raise " in line:
            warnings.append(f"Explicit raise at line {i}")

    return "\n".join(warnings) if warnings else "No obvious exception-causing patterns found"

# === Example Python code to analyze ===
code_to_check = """
x = 10 / 0
y = int("abc")
z = arr[5]
raise ValueError("manual raise")
"""

# Run the detector (SiSo style)
result = detect_exceptions(code_to_check)
print(result)

```
# Conclusion

- Our `DetectThrowsException` program is a simple, yet powerful illustration of a decision problem. While it doesn't solve the problem of definitively proving whether an exception will be thrown, it provides a crucial first step. We've seen how a pattern-matching approach using regular expressions can serve as a heuristicâ€”a practical, albeit imperfect, method to predict potential issues in source code.

- This project highlights a key challenge in `theoretical` computer science: `halting` problem variants. Just as we can't create a universal program to determine if another program will halt, we also can't create a perfect static analysis tool to predict all `runtime` exceptions. Our program's inability to account for runtime values, user input, or conditional logic shows that this is an undecidable problem in its full generality.

- Ultimately, our 'detector' isn't a flawless oracle; it's a predictive model for a class of problems that are theoretically impossible to solve with 100% certainty. We hope this project demonstrates how even a simple, `heuristic` approach can provide significant value in the real world of software development.
---

